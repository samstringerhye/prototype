import * as React from 'react'
import {
	PropertyControls,
	ControlType,
	FrameProperties,
	Frame,
	FramerEvent,
	RadiusValue,
} from 'framer'

/* ========================================================================== */
/*                                    TYPES                                   */
/* ========================================================================== */

interface TransitionsProps {
	stacked: {
		[key: string]: any
	}
	queued: {
		[key: string]: any
	}
	current: {
		[key: string]: any
	}
}

// Define type of property
interface RouterProps extends FrameProperties {
	start: number
	routes: any[]
	onMount: (props: any) => any
	onTransitionStart: (props: any) => any
	onTransitionEnd: (props: any) => any
	duration: number
	swipeForward: boolean
	swipeBack: boolean
	transitions: TransitionsProps
}

interface MoverProps {
	from?: string
	to?: string
	duration: number
	height: number | RadiusValue
	width: number | RadiusValue
	transitions: TransitionsProps
}

/* ========================================================================== */
/*                                   ROUTER                                   */
/* ========================================================================== */

/**
 * @description A 'router' that supports a simple stacked navigation
 * @date 2019-01-08
 * @export
 * @class Router
 * @extends {React.Component<Props>}
 */
export class Router extends React.Component<RouterProps> {
	// Set default properties
	static defaultProps = {
		start: 0,
		routes: [],
		onMount: () => null,
		onTransitionStart: () => null,
		onTransitionEnd: () => null,
		duration: 360,
		swipeForward: false,
		swipeBack: false,
		transitions: {
			stacked: {
				filter: `brightness(.8)`,
				transform: 'translateX(0%)',
				pointerEvents: 'none',
				opacity: 1,
			},
			current: {
				filter: `brightness(1)`,
				transform: 'translateX(0%)',
				pointerEvents: 'auto',
				opacity: 1,
			},
			queued: {
				filter: `brightness(1)`,
				transform: 'translateX(100%)',
				pointerEvents: 'none',
				opacity: 1,
			},
		},
	}

	state = {
		current: null,
		stack: [],
		direction: 'forward',
		pointer: 0,
	}

	offsetX = 0
	offsetY = 0

	static propertyControls: PropertyControls = {
		start: {
			type: ControlType.Number,
			title: 'Start',
			displayStepper: true,
			defaultValue: 0,
		},
		routes: {
			type: ControlType.Array,
			title: 'Routes',
			propertyControl: { type: ControlType.ComponentInstance },
		},
		duration: {
			type: ControlType.Number,
			title: 'Duration',
			min: 0,
			max: 1000,
			defaultValue: 360,
		},
		swipeForward: {
			type: ControlType.Boolean,
			title: 'Swipe Forward',
			defaultValue: false,
		},
		swipeBack: {
			type: ControlType.Boolean,
			title: 'Swipe Back',
			defaultValue: true,
		},
	}

	/* -------------------------------- LifeCycle ------------------------------- */

	// Calls onMount on mount (used in overrides)
	componentDidMount() {
		let { routes, start } = this.props
		if (routes.length === 0) return

		start = this.clampIndex(routes, start)
		this.showFirst(routes, start)
		this.props.onMount(this)
	}

	// if we've recieved a new index (e.g. through overrides), show it next
	componentWillReceiveProps = (props: RouterProps) => {
		const { routes, start } = this.props
		let { routes: nextRoutes, start: nextStart } = props

		if (nextRoutes.length === 0) return

		nextStart = Math.max(Math.min(nextStart, nextRoutes.length - 1), 0)

		if (nextRoutes.length !== routes.length || nextStart !== start) {
			this.showFirst(nextRoutes, nextStart)
		}
	}

	/* --------------------------------- Private -------------------------------- */

	/**
	 * @description Clamp a route index into a safe number
	 * @param {number} index
	 * @returns
	 */
	private clampIndex = (routes: any[], index: number) => {
		return Math.min(Math.max(0, index), routes.length - 1)
	}

	/**
	 * @description Find the frame in our routes array return a clone
	 * @param {number} index
	 * @returns
	 */
	private getRouteFrame = (routes: any[], index: number | string) => {
		const { stack } = this.state
		const { width, height } = this.props

		if (typeof index === 'string') {
			index = routes.findIndex((f: any) => f.props.id === index)
			if (!index) {
				console.warn(
					`Tried to navigate to an id, ${index} that wasn't in our routes array.`
				)
				return
			}
		}

		index = this.clampIndex(routes, index)

		return React.cloneElement(routes[index], {
			left: 0,
			top: 0,
			width,
			height,
			opacity: 1,
			key: `${routes[index].props.id}_${stack.length}`,
		})
	}

	/**
	 * @description Start recording a pan offset
	 * @param {(FramerEvent | any)} event
	 */
	private startSwipe = (event: FramerEvent | any) => {
		this.offsetX = event.point.x
		this.offsetY = event.point.y
	}

	/**
	 * @description Stop recording a pan offset
	 * @param {(FramerEvent | any)} event
	 */
	private endSwipe = (event: FramerEvent | any) => {
		const { swipeForward, swipeBack } = this.props
		let { offsetX, offsetY } = this

		const minOffset = 16
		offsetX = event.point.x - offsetX
		offsetY = event.point.y - offsetY

		if (Math.abs(offsetX) < minOffset) return

		if (offsetX < 0 && swipeForward) {
			this.moveInStack(1)
		} else if (offsetX > 0 && swipeBack) {
			this.moveInStack(-1)
		}
	}

	/**
	 * @description Emit onTransitionState / onTransitionEnd events
	 * @memberof Router
	 */
	emitTransitions = () => {
		const { duration } = this.props
		this.props.onTransitionStart(this.state)
		setTimeout(() => this.props.onTransitionEnd(this.state), duration)
	}

	/* --------------------------------- Public --------------------------------- */

	public showFirst = (routes: any[], index: number | string) => {
		const route = {
			frame: this.getRouteFrame(routes, index),
			index,
		}

		const nextStack = [route]

		this.setState({
			current: route,
			stack: nextStack,
			direction: 'forward',
			pointer: 0,
		})
		return true
	}

	/**
	 * @description Navigate to a given route
	 * @param {(number | string)} index The index of the frame in the component's routes array or the id of the frame
	 * @returns
	 */
	public showNext = (index: number | string) => {
		const { routes } = this.props
		const { stack, pointer, current } = this.state

		const route = {
			frame: this.getRouteFrame(routes, index),
			index,
		}

		if (current && route.index === current.index) return

		const nextStack = [...stack.slice(0, pointer + 1), route]

		this.setState(
			{
				current: route,
				stack: nextStack,
				direction: 'forward',
				pointer: nextStack.length - 1,
			},
			this.emitTransitions
		)
		return true
	}

	/**
	 * @description move forward or backward in the stack without mutating it
	 * @param {number} delta
	 * @memberof Router
	 */
	public moveInStack = (delta: number) => {
		if (delta === 0) return
		const { pointer, stack } = this.state
		const next = stack[pointer + delta]
		if (!next) return

		this.setState(
			{
				current: next,
				pointer: pointer + delta,
				direction: delta > 0 ? 'forward' : 'backward',
			},
			this.emitTransitions
		)
	}

	/**
	 * @description Show the next lower item in the stack
	 * @memberof Router
	 */
	public showPrevious = () => this.moveInStack(-1)

	/* --------------------------------- Render --------------------------------- */

	render() {
		const { width, height, duration, transitions } = this.props
		const { stack, direction, pointer } = this.state

		let frames: any[],
			staticStack = stack.slice().map(({ frame }) => frame)

		if (stack.length === 0) {
			return <DefaultContent />
		}

		const moverProps = {
			width,
			height,
			duration,
			transitions,
		}

		const under = staticStack[pointer - 1]
		const current = staticStack[pointer]
		const over = staticStack[pointer + 1]

		if (staticStack.length === 1) {
			frames = [
				<Mover key={`ok_${current.props.id}`} to="current" {...moverProps}>
					{current}
				</Mover>,
			]
		} else if (direction === 'forward') {
			frames = [
				<Mover
					key={`ok_${under.props.id}`}
					to="stacked"
					from="current"
					{...moverProps}
				>
					{under}
				</Mover>,
				<Mover
					key={`ok_${current.props.id}`}
					from="queued"
					to="current"
					{...moverProps}
				>
					{current}
				</Mover>,
			]
		} else if (direction === 'backward') {
			frames = [
				<Mover
					key={`ok_${current.props.id}`}
					from="stacked"
					to="current"
					{...moverProps}
				>
					{current}
				</Mover>,
				over && (
					<Mover
						key={`ok_${over.props.id}`}
						from="current"
						to="queued"
						{...moverProps}
					>
						{over}
					</Mover>
				),
			]
		}

		return (
			<Frame
				height={height}
				width={width}
				background={null}
				overflow="hidden"
				onPanStart={this.startSwipe}
				onPanEnd={this.endSwipe}
			>
				{frames}
			</Frame>
		)
	}
}

/* ========================================================================== */
/*                                    MOVER                                   */
/* ========================================================================== */

/**
 * @description A component to wrap frames and handle transitions
 * @date 2019-01-08
 * @class Mover
 * @extends {React.Component<MoverProps>}
 */
class Mover extends React.Component<MoverProps> {
	containerRef: React.RefObject<HTMLDivElement> = React.createRef()

	static defaultProps = {
		duration: 360,
		to: 'current',
		from: undefined,
		transitions: {
			stacked: {
				filter: `brightness(.8)`,
				transform: 'translateX(0%)',
				pointerEvents: 'none',
				opacity: 1,
			},
			current: {
				filter: `brightness(1)`,
				transform: 'translateX(0%)',
				pointerEvents: 'auto',
				opacity: 1,
			},
			queued: {
				filter: `brightness(1)`,
				transform: 'translateX(100%)',
				pointerEvents: 'none',
				opacity: 1,
			},
		},
	}

	state = {
		transition: null,
		style: null,
	}

	componentDidMount() {
		this.transition(this.props)
	}

	componentWillReceiveProps(props) {
		this.transition(props)
	}

	/* --------------------------------- Private -------------------------------- */

	/**
	 * @description Update the transition state, then optionally update it again
	 * @param {string} transition
	 * @param {string} [next]
	 */
	private setTransition = (transition: string, next?: string) => {
		const { duration, transitions } = this.props

		this.setState(
			{
				transition,
				style: {
					...transitions[transition],
					transition: next ? 'none' : `all ${duration / 1000}s`,
				},
			},
			() => {
				setTimeout(() => {
					if (!next) return
					this.setTransition(next)
				}, 75)
			}
		)
	}

	/**
	 * @description Transition, depending on props received
	 * @date 2019-01-08
	 * @private
	 * @param {MoverProps} props
	 * @memberof Mover
	 */
	private transition(props: MoverProps) {
		const { to, from } = props

		if (!from) {
			this.setTransition(to)
		} else {
			this.setTransition(from, to)
		}
	}

	render() {
		const { height, width, children } = this.props
		const { style } = this.state

		return (
			<div
				ref={this.containerRef}
				hidden={!style}
				style={{
					position: 'absolute',
					left: 0,
					top: 0,
					height,
					width,
					...style,
				}}
			>
				{children}
			</div>
		)
	}
}

/* ========================================================================== */
/*                                   DEFAULT                                  */
/* ========================================================================== */

/**
 * @description Default appearance of the router before routes are added
 * @param {*} props
 * @returns
 */
const DefaultContent = (props: any) => {
	return (
		<div
			style={{
				height: '100%',
				display: 'grid',
				gridTemplateRows: '1fr min-content min-content min-content 1fr',
				gridGap: '8px',
				alignItems: 'center',
				color: '#8855FF',
				padding: '0 16px',
				background: 'rgba(136, 85, 255, 0.1)',
				overflow: 'hidden',
				flexDirection: 'column',
			}}
		>
			<div />
			<div>Connect your pages</div>
			<div />
		</div>
	)
}
