# Router

[@steveruizok](http://twitter.com/steveruizok)

Stack navigation - works a lot like FlowComponent did in Framer Classic.

## Introduction

Router uses a “stack” pattern to handle navigation. The component has an array of “routes” (the frames you connect to the component). It also has a “stack” of visited routes, and an index - the component’s current position within that stack. 

You can navigate from the top of the stack downward, through previously visited routes, and forward again to return to the top. However, whenever a new route is added to the stack, any routes above the current position are discarded. 

If that’s confusing, think of it like the undo feature in most apps: each time you make a change, you add to a stack of history states. You can undo backward and redo forward within that history stack, but once you make a new change, you fork the stack and can’t undo forward anymore.

## Usage

You can control the router through overrides. See below for examples.

### Properties

prop | type | default
---| ---|----
`index` | `number` | `0`
`routes`| `ComponentInstance[]` | `[]`
`onMount`|  `(router: Router) => any` | `() => null`
`onTransitionStart`|  `(state: RouterState) => any`  | `() => null`
`onTransitionEnd`|  `(state: RouterState) => any`  | `() => null`
`duration`|  `number` | `360`
`swipeForward`|  `boolean` | `false`
`swipeBack`|  `boolean`| `true`
`transitions`|  `TransitionsProps` | (see below)

## Transitions

The `transitions` prop is an object with styles for three states: `stacked` describes styles for the frames *lower* in the stack than the current index,`current` describes styles for the route at the current index, and `queued` describes styles for the routes that are *higher* in the stack than the current index.

The defaults for these values are:

```
defaultTransitions = {
    stacked: {
         filter: `brightness(.8)`,
         transform: 'translateX(0%)',
         pointerEvents: 'none',
         opacity: 1,
   },
     current: {
         filter: `brightness(1)`,
         transform: 'translateX(0%)',
         pointerEvents: 'auto',
         opacity: 1,
    },
     queued: {
         filter: `brightness(1)`,
         transform: 'translateX(100%)',
         pointerEvents: 'none',
         opacity: 1,
    },
}
```

When a route is added to the stack, the new route transitions from `queued` to `current`. The former current route transitions from `current` to `stacked`.

The component will automatically transition routes between these states: 

- When a user navigates lower in the stack, the former current route transitions from `current` to `queued`. The new current route transitions from `stacked` to `current`.
- When transitioning higher in the stack, or when a new route is added, the former current route transitions from `current` to `stacked`. The new current route transitions from `queued` to `current`. 

You can override these values through an override on the `transitions` property to customise the appearance of routes as they transition in and out.

## Methods

### showNext(route)
Navigates to a given route and adds it to the components ’stack’ of visited routes. This method mutates the stack: any routes higher than the current stack position are removed from the stack.

**Arguments**

`route` (`number | string`): If number, the index of the desired frame within this component’s routes array prop, starting from zero at the top of the list. If string, the id of the desired frame, regardless of its position in the component’s routes array prop.

```jsx
router.showNext(1)
router.showNext(`id_asd24z`)
```

*****

### showPrevious()
Navigates to the next lowest frame in the stack. This method does not mutate the stack.

```jsx
router.showPrevious()
```

*****

### moveInStack(delta)
Navigates to a relative position in the component’s stack of visited routes. This method does not mutate the stack.  Calling `router.moveInStack(-1)` is identical to calling `router.showPrevious()`.

**Arguments**

`delta` (`number`): The number of positions forward or backward to move within the stack.

```jsx
router.moveInStack(-2)
```

## Example Overrides

You can use this component imperatively, much like you used Framer's FlowComponent. To do so, override the `onMount` method, which receives the router component instance, and store this instance in a global variable. You can then use other overrides to manipulate the router through this variable. 

```javascript
import { Override } from 'framer'

let router

export const isNavigation: Override = props => {
	return {
		onMount(myRouter: any) {
			router = myRouter
			// console.log('Router mounted', router)
		},
		onTransitionStart(state: any) {
			// console.log('Transition started', state)
		},
		onTransitionEnd(state: any) {
			// console.log('Transition ended', state)
		},
	}
}

export const isBackButton: Override = props => {
	return {
		onTap() {
			router.showPrevious()
		},
	}
}

export const isTab1Button: Override = props => {
	return {
		onTap() {
			router.showNext(0)
		},
	}
}

export const isTab2Button: Override = props => {
	return {
		onTap() {
			router.showNext(1)
		},
	}
}

export const isTab3Button: Override = props => {
	return {
		onTap() {
			router.showNext(2)
		},
	}
}

export const isTab4Button: Override = props => {
	return {
		onTap() {
			router.showNext(3)
		},
	}
}
```

### Changelog

#### 1.2.0

- Bug fixes on mount / update
- Improved docs
- Breaking changes! Declarative stacks are hard, so no more of that for now: use the methods provided and the overrides in the examples, at least until hooks are in

#### 1.1.0

- Improved code base
- Removed dependencies.

#### 1.0.0

- speedy version to save my bacon
- Transition duration
- Initial route number
- Events:
  - OnMount
  - OnTransitionStart
  - OnTransitionEnd
- Swipe event controls
